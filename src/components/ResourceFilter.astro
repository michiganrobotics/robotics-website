---
// ResourceFilter.astro - Simple filtering for robodex resources
---

<style>
.resource-card {
  transition: all 0.3s ease;
  opacity: 1;
  transform: translateY(0);
}

.resource-card.hidden {
  opacity: 0;
  transform: translateY(-10px);
  pointer-events: none;
}

.filter-btn {
  transition: all 0.2s ease;
}

.filter-btn:hover {
  transform: translateY(-1px);
}

button.filter-btn.active {
  background-color: #FFCB05 !important;
  color: #00274C !important;
  border-color: #FFCB05 !important;
  transform: translateY(-1px) !important;
  box-shadow: 0 4px 12px rgba(255, 203, 5, 0.3) !important;
  font-weight: 600 !important;
  backdrop-filter: none !important;
}

button.filter-btn.active:hover {
  background-color: #FFCB05 !important;
  color: #00274C !important;
}

.resource-count {
  animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const filterButtons = document.querySelectorAll('.filter-btn');
  const resourceCards = document.querySelectorAll('.resource-card');
  const searchInput = document.getElementById('search-input');
  
  // Define filter groups
  const programFilters = ['undergraduate', 'masters', 'phd'];
  const helpFilters = ['all', 'academic', 'career', 'community', 'support', 'research', 'international'];
  
  let activeFilters = {
    program: null,
    help: 'all'
  };
  let searchTerm = '';
  
  // Set initial state
  updateActiveButtons();
  updateDisplay();
  
  // Search functionality
  if (searchInput) {
    searchInput.addEventListener('input', function(e) {
      searchTerm = e.target.value.toLowerCase();
      updateDisplay();
    });
  }
  
  filterButtons.forEach(button => {
    button.addEventListener('click', function() {
      const filter = this.getAttribute('data-filter');
      console.log('Button clicked:', filter);
      
      // Determine which filter group this belongs to
      if (programFilters.includes(filter)) {
        // Toggle program filter (allow deselecting)
        activeFilters.program = activeFilters.program === filter ? null : filter;
      } else if (helpFilters.includes(filter)) {
        activeFilters.help = filter;
      }
      
      console.log('Active filters:', activeFilters);
      
      // Update active buttons
      updateActiveButtons();
      
      // Update display
      updateDisplay();
    });
  });
  
  function updateActiveButtons() {
    filterButtons.forEach(btn => {
      const filter = btn.getAttribute('data-filter');
      const isActive = filter === activeFilters.program || filter === activeFilters.help;
      
      if (isActive) {
        btn.classList.add('active');
        // Force the styling with direct style application
        btn.style.backgroundColor = '#FFCB05';
        btn.style.color = '#00274C';
        btn.style.borderColor = '#FFCB05';
        btn.style.fontWeight = '600';
        btn.style.transform = 'translateY(-1px)';
        btn.style.boxShadow = '0 4px 12px rgba(255, 203, 5, 0.3)';
      } else {
        btn.classList.remove('active');
        // Reset to original styling
        btn.style.backgroundColor = '';
        btn.style.color = '';
        btn.style.borderColor = '';
        btn.style.fontWeight = '';
        btn.style.transform = '';
        btn.style.boxShadow = '';
      }
    });
  }
  
  function updateDisplay() {
    let visibleResourceCount = 0;
    
    resourceCards.forEach(card => {
      const categories = card.getAttribute('data-categories') || '';
      const categoryList = categories.split(' ');
      
      // Check program filter match
      const programMatch = !activeFilters.program || categoryList.includes(activeFilters.program);
      
      // Check help filter match  
      const helpMatch = activeFilters.help === 'all' || categoryList.includes(activeFilters.help);
      
      // Apply category filters to entire card
      if (!programMatch || !helpMatch) {
        card.classList.add('hidden');
        card.style.display = 'none';
        return;
      }
      
      // Count individual resources within this card
      const resourceLinks = card.querySelectorAll('a[data-search-terms]');
      let cardVisibleResources = 0;
      let hasVisibleItems = false;
      
      // For search, check individual items within the card
      if (searchTerm) {
        resourceLinks.forEach(link => {
          const listItem = link.closest('li');
          if (listItem) {
            const itemText = listItem.textContent?.toLowerCase() || '';
            const searchTerms = link.getAttribute('data-search-terms')?.toLowerCase() || '';
            const itemMatches = itemText.includes(searchTerm) || searchTerms.includes(searchTerm);
            
            if (itemMatches) {
              listItem.style.display = '';
              hasVisibleItems = true;
              cardVisibleResources++;
            } else {
              listItem.style.display = 'none';
            }
          }
        });
        
        // Show/hide the entire card based on whether it has visible items
        if (hasVisibleItems) {
          card.classList.remove('hidden');
          card.style.display = 'block';
          visibleResourceCount += cardVisibleResources;
        } else {
          card.classList.add('hidden');
          card.style.display = 'none';
        }
      } else {
        // No search term - show all items and count all resources in this card
        const allItems = card.querySelectorAll('li');
        allItems.forEach(item => {
          item.style.display = '';
        });
        
        card.classList.remove('hidden');
        card.style.display = 'block';
        visibleResourceCount += resourceLinks.length;
      }
    });
    
    updateCount(visibleResourceCount);
  }
  
  function updateCount(visibleCount) {
    let countElement = document.querySelector('.resource-count');
    
    if (!countElement) {
      countElement = document.createElement('div');
      countElement.className = 'resource-count text-sm text-gray-100 mt-4 relative z-10 text-center';
      
      // Find the filter sidebar - look for the first filter-section which should be the sidebar
      const filterSidebar = document.querySelector('.filter-section');
      console.log('Filter sidebar found:', filterSidebar);
      
      if (filterSidebar) {
        filterSidebar.appendChild(countElement);
        console.log('Count element added to sidebar');
      } else {
        // Fallback to original location if sidebar not found
        console.log('Sidebar not found, using fallback location');
        const fallbackContainer = document.querySelector('.masonry-container');
        if (fallbackContainer && fallbackContainer.parentNode) {
          fallbackContainer.parentNode.appendChild(countElement);
        }
      }
    }
    
    // Calculate total number of individual resources across all cards
    let totalResourceCount = 0;
    resourceCards.forEach(card => {
      const resourceLinks = card.querySelectorAll('a[data-search-terms]');
      totalResourceCount += resourceLinks.length;
    });
    
    const activeFilterText = [];
    if (activeFilters.program) activeFilterText.push(activeFilters.program);
    if (activeFilters.help !== 'all') activeFilterText.push(activeFilters.help);
    if (searchTerm) activeFilterText.push(`search: "${searchTerm}"`);
    
    const filterDisplay = activeFilterText.length > 0 ? activeFilterText.join(' + ') : 'all';
    countElement.innerHTML = `Showing ${visibleCount} of ${totalResourceCount} resources<br><small class="text-xs">Active filters: ${filterDisplay}</small>`;
  }
});
</script>