---
interface Props {
  sections: { id: string; title: string }[];
}

const { sections } = Astro.props;
---

<nav class="mb-8 lg:sticky lg:top-0 lg:z-10 not-prose" id="toc-container" aria-label="Table of contents">
  <div class="surface-secondary dark:!bg-arboretumBlue/95 !border-0 !border-t-2 !border-maize rounded-b-lg p-2 pb-4 transition-shadow duration-300" id="toc-content">
    <h3 class="font-semibold mb-1 ml-4" id="toc-heading">Topics</h3>
    <ul class="ml-4 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-1 text-sm list-none" role="list" aria-labelledby="toc-heading">
      {sections.map(section => (
        <li>
          <a 
            href={`#${section.id}`} 
            class="toc-link transition-colors duration-200 py-1 px-2 rounded block" 
            data-section={section.id}
            aria-describedby="toc-instructions"
          >
            {section.title}
          </a>
        </li>
      ))}
    </ul>
    <div id="toc-instructions" class="sr-only">Navigate to page sections. Current section is highlighted.</div>
  </div>
</nav>

<style>
  @reference "../styles/global.css";
  .toc-link.active {
    @apply text-maize underline font-medium;
  }
  
  .toc-link.active:hover {
    @apply text-maize;
  }
  
  
</style>

<script>
  function updateActiveSection() {
    const tocLinks = document.querySelectorAll('.toc-link');
    const sections = Array.from(tocLinks).map(link => link.getAttribute('data-section')).filter(Boolean);
    
    let currentSection = '';
    
    // Check if we're near the bottom of the page
    const isNearBottom = (window.innerHeight + window.scrollY) >= document.body.offsetHeight - 80;
    
    if (isNearBottom && sections.length > 0) {
      // If near bottom, highlight the last section
      currentSection = sections[sections.length - 1];
    } else {
      // Find which section is currently in view
      for (let i = sections.length - 1; i >= 0; i--) {
        const element = document.getElementById(sections[i]);
        if (element) {
          const rect = element.getBoundingClientRect();
          if (rect.top <= 150) { // Account for sticky header offset
            currentSection = sections[i];
            break;
          }
        }
      }
    }
    
    // Update active states
    tocLinks.forEach(link => {
      const section = link.getAttribute('data-section');
      if (section === currentSection) {
        link.classList.add('active');
        link.setAttribute('aria-current', 'location');
      } else {
        link.classList.remove('active');
        link.removeAttribute('aria-current');
      }
    });
  }
  
  function updateTocStickyState() {
    const tocContainer = document.getElementById('toc-container');
    const tocContent = document.getElementById('toc-content');
    
    if (tocContainer && tocContent) {
      const containerRect = tocContainer.getBoundingClientRect();
      const isSticky = containerRect.top <= 0;
      
      if (isSticky) {
        tocContent.classList.add('shadow-lg');
      } else {
        tocContent.classList.remove('shadow-lg');
      }
    }
  }
  
  // Throttle scroll events for better performance
  let ticking = false;
  function requestTick() {
    if (!ticking) {
      requestAnimationFrame(() => {
        updateActiveSection();
        updateTocStickyState();
      });
      ticking = true;
      setTimeout(() => { ticking = false; }, 10);
    }
  }
  
  // Update on scroll
  window.addEventListener('scroll', requestTick);
  
  // Add scroll margin CSS to headings dynamically only on lg screens
  function updateScrollMarginForScreenSize() {
    const isLargeScreen = window.matchMedia('(min-width: 1024px)').matches;
    
    // Remove existing style if it exists
    const existingStyle = document.getElementById('toc-scroll-margin');
    if (existingStyle) {
      existingStyle.remove();
    }
    
    // Add scroll margin only on large screens where ToC is sticky
    if (isLargeScreen) {
      const style = document.createElement('style');
      style.id = 'toc-scroll-margin';
      style.textContent = `
        h1, h2, h3, h4, h5, h6 {
          scroll-margin-top: 120px !important;
        }
      `;
      document.head.appendChild(style);
    }
  }

  // Update on load
  document.addEventListener('DOMContentLoaded', () => {
    updateActiveSection();
    updateTocStickyState();
    updateScrollMarginForScreenSize();
  });
  
  // Update when hash changes (for direct navigation)
  window.addEventListener('hashchange', updateActiveSection);
  
  // Update scroll margin when screen size changes
  window.addEventListener('resize', updateScrollMarginForScreenSize);
  
  // Handle ToC link clicks with proper offset
  document.addEventListener('click', (e) => {
    const link = e.target.closest('.toc-link');
    if (link && link.getAttribute('href').startsWith('#')) {
      e.preventDefault();
      const targetId = link.getAttribute('href').substring(1);
      const targetElement = document.getElementById(targetId);
      
      if (targetElement) {
        const isLargeScreen = window.matchMedia('(min-width: 1024px)').matches;
        let targetPosition = targetElement.offsetTop;
        
        // Only apply offset on large screens where ToC is sticky
        if (isLargeScreen) {
          const tocHeight = document.getElementById('toc-container')?.offsetHeight || 100;
          const offset = tocHeight + 20; // Add some extra padding
          targetPosition = targetElement.offsetTop - offset;
        }
        
        window.scrollTo({
          top: targetPosition,
          behavior: 'smooth'
        });
        
        // Update URL hash
        history.pushState(null, null, `#${targetId}`);
      }
    }
  });
</script>